<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="c  Row definitions."><title>rows in zng_wgt_grid - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="zng_wgt_grid" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo-icon.png"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../zng_wgt_grid/index.html"><img src="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../zng_wgt_grid/index.html"><img src="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo.png" alt="logo"></a><h2><a href="../zng_wgt_grid/index.html">zng_<wbr>wgt_<wbr>grid</a><span class="version">0.8.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">rows</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#layout-modes" title="Layout Modes">Layout Modes</a><ul><li><a href="#notes" title="Notes">Notes</a></li></ul></li><li><a href="#capture-only" title="Capture-Only">Capture-Only</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate zng_<wbr>wgt_<wbr>grid</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">zng_wgt_grid</a></div><h1>Function <span class="fn">rows</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/zng_wgt_grid/lib.rs.html#145">Source</a> </span></div><pre class="rust item-decl"><code>pub fn rows(cells: impl <a class="trait" href="../zng_app/widget/node/trait.IntoUiNode.html" title="trait zng_app::widget::node::IntoUiNode">IntoUiNode</a>)</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><strong title='Capture-only property function' data-tag='c'><code>c</code></strong>  Row definitions.</p>
<p>Rows are defined by widgets, the row widget height defines the height of cells assigned to the row, the <a href="struct.Row.html" title="struct zng_wgt_grid::Row"><code>Row!</code></a> widget is recommended,
but you can use any widget to define a row. The row widget is rendered as the background of the row region, behind cells and in front
of column backgrounds.</p>
<h3 id="layout-modes"><a class="doc-anchor" href="#layout-modes">§</a>Layout Modes</h3>
<p>The grid uses the <a href="../zng_wgt_size_offset/struct.WIDGET_SIZE.html" title="struct zng_wgt_size_offset::WIDGET_SIZE"><code>WIDGET_SIZE</code></a> value to select one of three layout modes for rows:</p>
<ul>
<li><em>Default</em>, used for rows that do not set height or set it to <a href="../zng_layout/unit/length/enum.Length.html#variant.Default" title="variant zng_layout::unit::length::Length::Default"><code>Length::Default</code></a>.</li>
<li><em>Exact</em>, used for rows that set the height to an unit that is exact or only depends on the grid context.</li>
<li><em>Leftover</em>, used for rows that set height to a <a href="../zng_layout/unit/length/trait.LengthUnits.html#tymethod.lft" title="method zng_layout::unit::length::LengthUnits::lft"><code>lft</code></a> value.</li>
</ul>
<p>The row measure follows the same steps as <a href="fn.columns.html" title="fn zng_wgt_grid::columns"><code>columns</code></a>, the only difference is that there is no
overflow recovery for row heights exceeding the available height.</p>
<h4 id="notes"><a class="doc-anchor" href="#notes">§</a>Notes</h4>
<p>Note that the row widget is not the parent of the cells that match it.
Properties like <code>padding</code> and <code>align</code> only affect the row visual, not the cells, similarly contextual properties like <code>text_color</code>
don’t affect the cells.</p>
<p>Note that the <em>Default</em> layout mode scales with the cell count, the other modes scale with the row count. This has less impact
for rows, but you should consider setting a fixed row height for larger grids. Also note that you can define the <a href="fn.auto_grow_fn.html" title="fn zng_wgt_grid::auto_grow_fn"><code>auto_grow_fn</code></a>
instead of manually adding rows. With fixed heights a data table of up to 1000 rows with simple text cells should have good performance.</p>
<p>For massive data tables consider a paginating layout with a separate grid instance per <em>page</em>, the page grids don’t need to be actually
presented as pages, you can use lazy loading and a simple stack layout to seamless virtualize data loading and presentation.</p>
<h2 id="capture-only"><a class="doc-anchor" href="#capture-only">§</a>Capture-Only</h2>
<p>This property is capture-only, it only defines a property signature, it does not implement any behavior by itself.
Widgets can capture and implement this property as part of their intrinsics, otherwise it will have no
effect if set on a widget that does not implement it.</p>
</div></details></section></div></main></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="IPC tasks."><title>zng_task::ipc - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="zng_task" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo-icon.png"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../zng_task/index.html"><img src="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../zng_task/index.html"><img src="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo.png" alt="logo"></a><h2><a href="../../zng_task/index.html">zng_<wbr>task</a><span class="version">0.4.7</span></h2></div><h2 class="location"><a href="#">Module ipc</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate zng_<wbr>task</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">zng_task</a>::<wbr><a class="mod" href="#">ipc</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/zng_task/ipc.rs.html#1-491">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>IPC tasks.</p>
<p>This module uses <a href="https://docs.rs/ipc-channel"><code>ipc_channel</code></a> and <a href="https://docs.rs/duct"><code>duct</code></a> crates to define a worker process that can run tasks in a separate process instance.</p>
<p>Each worker process can run multiple tasks in parallel, the worker type is <a href="struct.Worker.html" title="struct zng_task::ipc::Worker"><code>Worker</code></a>. Note that this module does not offer a fork
implementation, the worker processes begin from the start state. The primary use of process tasks is to make otherwise fatal tasks
recoverable, if the task calls unsafe code or code that can potentially terminate the entire process it should run using a <a href="struct.Worker.html" title="struct zng_task::ipc::Worker"><code>Worker</code></a>.
If you only want to recover from panics in safe code consider using <a href="../fn.run_catch.html" title="fn zng_task::run_catch"><code>task::run_catch</code></a> or <a href="../fn.wait_catch.html" title="fn zng_task::wait_catch"><code>task::wait_catch</code></a> instead.</p>
<p>This module also re-exports some <a href="https://docs.rs/ipc-channel"><code>ipc_channel</code></a> types and functions. You can send IPC channels in the task request messages, this
can be useful for implementing progress reporting or to transfer large byte blobs.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>The example below demonstrates a worker-process setup that uses the same executable as the app-process.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main() {
    <span class="macro">zng::env::init!</span>();
    <span class="comment">// normal app init..
</span>}

<span class="kw">mod </span>task1 {
    <span class="kw">use </span>zng::{task::ipc, env};

    <span class="kw">const </span>NAME: <span class="kw-2">&amp;</span>str = <span class="string">"zng::example::task1"</span>;

    <span class="macro">env::on_process_start!</span>(|<span class="kw">_</span>| ipc::run_worker(NAME, work));
    <span class="kw">async fn </span>work(args: ipc::RequestArgs&lt;Request&gt;) -&gt; Response {
        <span class="kw">let </span>rsp = <span class="macro">format!</span>(<span class="string">"received 'task1' request `{:?}` in worker-process #{}"</span>, <span class="kw-2">&amp;</span>args.request.data, std::process::id());
        Response { data: rsp }
    }
     
    <span class="attr">#[derive(Debug, serde::Serialize, serde::Deserialize)]
    </span><span class="kw">pub struct </span>Request { <span class="kw">pub </span>data: String }

    <span class="attr">#[derive(Debug, serde::Serialize, serde::Deserialize)]
    </span><span class="kw">pub struct </span>Response { <span class="kw">pub </span>data: String }

    <span class="comment">// called in app-process
    </span><span class="kw">pub async fn </span>start() -&gt; ipc::Worker&lt;Request, Response&gt; {
        ipc::Worker::start(NAME).<span class="kw">await</span>.expect(<span class="string">"cannot spawn 'task1'"</span>)
    }
}

<span class="comment">// This runs in the app-process, it starts a worker process and requests a task run.
</span><span class="kw">async fn </span>on_click() {
    <span class="macro">println!</span>(<span class="string">"app-process #{} starting a worker"</span>, std::process::id());
    <span class="kw">let </span><span class="kw-2">mut </span>worker = task1::start().<span class="kw">await</span>;
    <span class="comment">// request a task run and await it.
    </span><span class="kw">match </span>worker.run(task1::Request { data: <span class="string">"request"</span>.to_owned() }).<span class="kw">await </span>{
        <span class="prelude-val">Ok</span>(task1::Response { data }) =&gt; <span class="macro">println!</span>(<span class="string">"ok. {data}"</span>),
        <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">eprintln!</span>(<span class="string">"error: {e}"</span>),
    }
    <span class="comment">// multiple tasks can be requested in parallel, use `task::all!` to await ..

    // the worker process can be gracefully shutdown, awaits all pending tasks.
    </span><span class="kw">let _ </span>= worker.shutdown().<span class="kw">await</span>;
}
</code></pre></div>
<p>Note that you can setup multiple workers the same executable, as long as the <code>on_process_start!</code> call happens
on different modules.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.bytes_channel"><code>pub use ipc_channel::ipc::bytes_channel;</code></div></li><li><div class="item-name" id="reexport.IpcBytesReceiver"><code>pub use ipc_channel::ipc::IpcBytesReceiver;</code></div></li><li><div class="item-name" id="reexport.IpcBytesSender"><code>pub use ipc_channel::ipc::IpcBytesSender;</code></div></li><li><div class="item-name" id="reexport.IpcReceiver"><code>pub use ipc_channel::ipc::IpcReceiver;</code></div></li><li><div class="item-name" id="reexport.IpcSender"><code>pub use ipc_channel::ipc::IpcSender;</code></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.RequestArgs.html" title="struct zng_task::ipc::RequestArgs">Request<wbr>Args</a></div><div class="desc docblock-short">Arguments for <a href="fn.run_worker.html" title="fn zng_task::ipc::run_worker"><code>run_worker</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Worker.html" title="struct zng_task::ipc::Worker">Worker</a></div><div class="desc docblock-short">Represents a running worker process.</div></li><li><div class="item-name"><a class="struct" href="struct.WorkerCrashError.html" title="struct zng_task::ipc::WorkerCrashError">Worker<wbr>Crash<wbr>Error</a></div><div class="desc docblock-short">Info about a worker process crash.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.RunError.html" title="enum zng_task::ipc::RunError">RunError</a></div><div class="desc docblock-short">Worker run error.</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.VERSION.html" title="constant zng_task::ipc::VERSION">VERSION</a></div><div class="desc docblock-short">The <em>App Process</em> and <em>Worker Process</em> must be build using the same exact version and this is
validated during run-time, causing a panic if the versions don’t match.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.IpcValue.html" title="trait zng_task::ipc::IpcValue">IpcValue</a></div><div class="desc docblock-short">Represents a type that can be an input and output of IPC workers.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.run_worker.html" title="fn zng_task::ipc::run_worker">run_<wbr>worker</a></div><div class="desc docblock-short">If the process was started by a <a href="struct.Worker.html" title="struct zng_task::ipc::Worker"><code>Worker</code></a> runs the worker loop and never returns. If
not started as worker does nothing.</div></li></ul></section></div></main></body></html>
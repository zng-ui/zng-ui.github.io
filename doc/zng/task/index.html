<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Parallel async tasks and async task runners."><title>zng::task - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="zng" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo-icon.png"><link rel="stylesheet" href="/doc/zng-material-icons-extensions.css">
</head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../zng/index.html"><img src="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../zng/index.html"><img src="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo.png" alt="logo"></a><h2><a href="../../zng/index.html">zng</a><span class="version">0.11.1</span></h2></div><h2 class="location"><a href="#">Module task</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate zng</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">zng</a>::<wbr><a class="mod" href="#">task</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/zng/task.rs.html#1-164">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Parallel async tasks and async task runners.</p>
<p>Use <a href="fn.run.html" title="fn zng::task::run"><code>run</code></a>, <a href="fn.respond.html" title="fn zng::task::respond"><code>respond</code></a> or <a href="fn.spawn.html" title="fn zng::task::spawn"><code>spawn</code></a> to run parallel tasks, use <a href="fn.wait.html" title="fn zng::task::wait"><code>wait</code></a>, <a href="io/index.html" title="mod zng::task::io"><code>io</code></a> and <a href="fs/index.html" title="mod zng::task::fs"><code>fs</code></a> to unblock
IO operations and use <a href="http/index.html" title="mod zng::task::http"><code>http</code></a> for async HTTP.</p>
<p>All functions of this module propagate the <a href="../app/struct.LocalContext.html" title="struct zng::app::LocalContext"><code>LocalContext</code></a>.</p>
<p>This crate also re-exports the <a href="https://docs.rs/rayon"><code>rayon</code></a> and <a href="https://docs.rs/parking_lot"><code>parking_lot</code></a> crates for convenience. You can use the
<a href="trait.ParallelIteratorExt.html#method.with_ctx" title="method zng::task::ParallelIteratorExt::with_ctx"><code>ParallelIteratorExt::with_ctx</code></a> adapter in rayon iterators to propagate the <a href="../app/struct.LocalContext.html" title="struct zng::app::LocalContext"><code>LocalContext</code></a>. You can
also use <a href="fn.join.html" title="fn zng::task::join"><code>join</code></a> to propagate thread context for a raw rayon join operation.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zng::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>enabled = var(<span class="bool-val">false</span>);
<span class="macro">Button!</span> {
    on_click = <span class="macro">async_hn!</span>(enabled, |<span class="kw">_</span>| {
        enabled.set(<span class="bool-val">false</span>);

        <span class="kw">let </span>sum_task = task::run(<span class="kw">async </span>{
            <span class="kw">let </span>numbers = read_numbers().<span class="kw">await</span>;
            numbers.par_iter().map(|i| i * i).sum()
        });
        <span class="kw">let </span>sum: usize = sum_task.<span class="kw">await</span>;
        <span class="macro">println!</span>(<span class="string">"sum of squares: {sum}"</span>);

        enabled.set(<span class="bool-val">true</span>);
    });
    widget::enabled = enabled;
}

<span class="kw">async fn </span>read_numbers() -&gt; Vec&lt;usize&gt; {
    <span class="kw">let </span>raw = task::wait(|| std::fs::read_to_string(<span class="string">"numbers.txt"</span>).unwrap()).<span class="kw">await</span>;
    raw.par_split(<span class="string">','</span>).map(|s| s.trim().parse::&lt;usize&gt;().unwrap()).collect()
}</code></pre></div>
<p>The example demonstrates three different <em><strong>tasks</strong></em>, the first is a <a href="struct.UiTask.html" title="struct zng::task::UiTask"><code>UiTask</code></a> in the <code>async_hn</code> handler,
this task is <em>async</em> but not <em>parallel</em>, meaning that it will execute in more then one app update, but it will only execute in the
<code>on_click</code> context and thread. This is good for coordinating UI state, like setting variables, but is not good if you want to do CPU intensive work.</p>
<p>To keep the app responsive we move the computation work inside a <a href="fn.run.html" title="fn zng::task::run"><code>run</code></a> task, this task is <em>async</em> and <em>parallel</em>,
meaning it can <code>.await</code> and will execute in parallel threads. It runs in a <a href="https://docs.rs/rayon"><code>rayon</code></a> thread-pool so you can
easily make the task multi-threaded and when it is done it sends the result back to the widget task that is awaiting for it. We
resolved the responsiveness problem, but there is one extra problem to solve, how to not block one of the worker threads waiting IO.</p>
<p>We want to keep the <a href="fn.run.html" title="fn zng::task::run"><code>run</code></a> threads either doing work or available for other tasks, but reading a file is just waiting
for a potentially slow external operation, so if we call <a href="https://doc.rust-lang.org/1.80.1/std/fs/fn.read_to_string.html" title="fn std::fs::read_to_string"><code>std::fs::read_to_string</code></a> directly we can potentially remove one of
the worker threads from play, reducing the overall tasks performance. To avoid this we move the IO operation inside a <a href="fn.wait.html" title="fn zng::task::wait"><code>wait</code></a>
task, this task is not <em>async</em> but it is <em>parallel</em>, meaning if does not block but it runs a blocking operation. It runs inside
a <a href="https://docs.rs/blocking"><code>blocking</code></a> thread-pool, that is optimized for waiting.</p>
<h2 id="async-io"><a class="doc-anchor" href="#async-io">§</a>Async IO</h2>
<p>You can use <a href="fn.wait.html" title="fn zng::task::wait"><code>wait</code></a>, <a href="io/index.html" title="mod zng::task::io"><code>io</code></a> and <a href="fs/index.html" title="mod zng::task::fs"><code>fs</code></a> to do async IO, Zng uses this API for internal async IO, they are just a selection
of external async crates re-exported for convenience and compatibility.</p>
<p>The <a href="io/index.html" title="mod zng::task::io"><code>io</code></a> module just re-exports the <a href="https://docs.rs/futures-lite/*/futures_lite/io/index.html"><code>futures-lite::io</code></a> traits and types, adding only progress tracking. The
<a href="fs/index.html" title="mod zng::task::fs"><code>fs</code></a> module is the <a href="https://docs.rs/async-fs"><code>async-fs</code></a> crate. Most of the IO async operations are implemented using extensions traits
so we recommend blob importing <a href="io/index.html" title="mod zng::task::io"><code>io</code></a> to start implementing async IO.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zng::prelude::<span class="kw-2">*</span>;

<span class="kw">async fn </span>read_numbers() -&gt; <span class="prelude-ty">Result</span>&lt;Vec&lt;usize&gt;, Box&lt;<span class="kw">dyn </span>std::error::Error + Send + Sync&gt;&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>file = task::fs::File::open(<span class="string">"numbers.txt"</span>).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>raw = String::new();
    file.read_to_string(<span class="kw-2">&amp;mut </span>raw).<span class="kw">await</span><span class="question-mark">?</span>;
    raw.par_split(<span class="string">','</span>).map(|s| s.trim().parse::&lt;usize&gt;().map_err(Into::into)).collect()
}</code></pre></div>
<p>All the <code>std::fs</code> synchronous operations have an async counterpart in <a href="fs/index.html" title="mod zng::task::fs"><code>fs</code></a>. For simpler one shot
operation it is recommended to just use <code>std::fs</code> inside <a href="fn.wait.html" title="fn zng::task::wait"><code>wait</code></a>, the async <a href="fs/index.html" title="mod zng::task::fs"><code>fs</code></a> types are not async at
the OS level, they only offload operations inside the same thread-pool used by <a href="fn.wait.html" title="fn zng::task::wait"><code>wait</code></a>.</p>
<h2 id="http-client"><a class="doc-anchor" href="#http-client">§</a>HTTP Client</h2>
<p>You can use <a href="http/index.html" title="mod zng::task::http"><code>http</code></a> to implement asynchronous HTTP requests. Zng also uses the <a href="http/index.html" title="mod zng::task::http"><code>http</code></a> module for
implementing operations such as loading an image from a given URL, the module is a thin wrapper around the <a href="https://docs.rs/isahc"><code>isahc</code></a> crate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zng::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>enabled = var(<span class="bool-val">false</span>);
<span class="kw">let </span>msg = var(<span class="string">"loading.."</span>.to_txt());
<span class="macro">Button!</span> {
    on_click = <span class="macro">async_hn!</span>(enabled, msg, |<span class="kw">_</span>| {
        enabled.set(<span class="bool-val">false</span>);

        <span class="kw">match </span>task::http::get_txt(<span class="string">"https://httpbin.org/get"</span>).<span class="kw">await </span>{
            <span class="prelude-val">Ok</span>(r) =&gt; msg.set(r),
            <span class="prelude-val">Err</span>(e) =&gt; msg.set(<span class="macro">formatx!</span>(<span class="string">"error: {e}"</span>)),
        }

        enabled.set(<span class="bool-val">true</span>);
    });
}</code></pre></div>
<p>For other protocols or alternative HTTP clients you can use <a href="#async-crates-integration">external crates</a>.</p>
<h2 id="async-crates-integration"><a class="doc-anchor" href="#async-crates-integration">§</a>Async Crates Integration</h2>
<p>You can use external async crates to create futures and then <code>.await</code> then in async code managed by Zng, but there is some
consideration needed. Async code needs a runtime to execute and some async functions from external crates expect their own runtime
to work properly, as a rule of thumb if the crate starts their own <em>event reactor</em> you can just use then without worry.</p>
<p>You can use the <a href="https://docs.rs/futures"><code>futures</code></a>, <a href="https://docs.rs/async-std"><code>async-std</code></a> and <a href="https://docs.rs/smol"><code>smol</code></a> crates without worry, they integrate well and even use the same <a href="https://docs.rs/blocking"><code>blocking</code></a>
thread-pool that is used in <a href="fn.wait.html" title="fn zng::task::wait"><code>wait</code></a>. Functions that require an <em>event reactor</em> start it automatically, usually at the cost of one extra
thread only. Just <code>.await</code> futures from these crate.</p>
<p>The <a href="https://docs.rs/tokio"><code>tokio</code></a> crate on the other hand, does not integrate well. It does not start its own runtime automatically, and expects you
to call its async functions from inside the tokio runtime. After you create a future from inside the runtime you can <code>.await</code> then
in any thread, so we recommend manually starting its runtime in a thread and then using the <code>tokio::runtime::Handle</code> to start
futures in the runtime.</p>
<p>External tasks also don’t propagate the thread context, if you want access to app services or want to set vars inside external
parallel closures you must capture and load the <a href="../app/struct.LocalContext.html" title="struct zng::app::LocalContext"><code>LocalContext</code></a> manually.</p>
<h2 id="full-api"><a class="doc-anchor" href="#full-api">§</a>Full API</h2>
<p>This module fully re-exports <a href="../../zng_task/index.html" title="mod zng_task"><code>zng_task</code></a>.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.parking_lot"><code>pub use zng_task::parking_lot;</code></div></li><li><div class="item-name" id="reexport.rayon"><code>pub use zng_task::rayon;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="channel/index.html" title="mod zng::task::channel">channel</a></div><div class="desc docblock-short">Async channels.</div></li><li><div class="item-name"><a class="mod" href="fs/index.html" title="mod zng::task::fs">fs</a></div><div class="desc docblock-short">Async filesystem primitives.</div></li><li><div class="item-name"><a class="mod" href="http/index.html" title="mod zng::task::http">http</a></div><div class="desc docblock-short">HTTP client.</div></li><li><div class="item-name"><a class="mod" href="io/index.html" title="mod zng::task::io">io</a></div><div class="desc docblock-short">IO tasks.</div></li><li><div class="item-name"><a class="mod" href="ipc/index.html" title="mod zng::task::ipc">ipc</a></div><div class="desc docblock-short">IPC tasks.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.all.html" title="macro zng::task::all">all</a></div><div class="desc docblock-short"><span data-del-macro-root></span> A future that <em>zips</em> other futures.</div></li><li><div class="item-name"><a class="macro" href="macro.all_ok.html" title="macro zng::task::all_ok">all_ok</a></div><div class="desc docblock-short"><span data-del-macro-root></span> A future that is ready when all futures are ready with an <code>Ok(T)</code> result or
any future is ready with an <code>Err(E)</code> result.</div></li><li><div class="item-name"><a class="macro" href="macro.all_some.html" title="macro zng::task::all_some">all_some</a></div><div class="desc docblock-short"><span data-del-macro-root></span> A future that is ready when all futures are ready with <code>Some(T)</code> or when any
is future ready with <code>None</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.any.html" title="macro zng::task::any">any</a></div><div class="desc docblock-short"><span data-del-macro-root></span> A future that awaits for the first future that is ready.</div></li><li><div class="item-name"><a class="macro" href="macro.any_ok.html" title="macro zng::task::any_ok">any_ok</a></div><div class="desc docblock-short"><span data-del-macro-root></span> A future that waits for the first future that is ready with an <code>Ok(T)</code> result.</div></li><li><div class="item-name"><a class="macro" href="macro.any_some.html" title="macro zng::task::any_some">any_some</a></div><div class="desc docblock-short"><span data-del-macro-root></span> A future that is ready when any of the futures is ready and <code>Some(T)</code>.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.DeadlineError.html" title="struct zng::task::DeadlineError">DeadlineError</a></div><div class="desc docblock-short">Error when <a href="fn.with_deadline.html" title="fn zng::task::with_deadline"><code>with_deadline</code></a> reach a time limit before a task finishes.</div></li><li><div class="item-name"><a class="struct" href="struct.McWaker.html" title="struct zng::task::McWaker">McWaker</a></div><div class="desc docblock-short">A <a href="https://doc.rust-lang.org/1.80.1/core/task/wake/struct.Waker.html" title="struct core::task::wake::Waker"><code>Waker</code></a> that dispatches a wake call to multiple other wakers.</div></li><li><div class="item-name"><a class="struct" href="struct.ParallelIteratorWithCtx.html" title="struct zng::task::ParallelIteratorWithCtx">ParallelIteratorWithCtx</a></div><div class="desc docblock-short">Parallel iterator adapter the propagates the thread context.</div></li><li><div class="item-name"><a class="struct" href="struct.ScopeCtx.html" title="struct zng::task::ScopeCtx">ScopeCtx</a></div><div class="desc docblock-short">Represents a fork-join scope which can be used to spawn any number of tasks that run in the caller’s thread context.</div></li><li><div class="item-name"><a class="struct" href="struct.SignalOnce.html" title="struct zng::task::SignalOnce">SignalOnce</a></div><div class="desc docblock-short">A future that will await until <a href="struct.SignalOnce.html#method.set" title="method zng::task::SignalOnce::set"><code>set</code></a> is called.</div></li><li><div class="item-name"><a class="struct" href="struct.UiTask.html" title="struct zng::task::UiTask">UiTask</a></div><div class="desc docblock-short">Represents a <a href="https://doc.rust-lang.org/1.80.1/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> running in sync with the UI.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ParallelIteratorExt.html" title="trait zng::task::ParallelIteratorExt">ParallelIteratorExt</a></div><div class="desc docblock-short">Extends rayon’s <code>ParallelIterator</code> with thread context.</div></li><li><div class="item-name"><a class="trait" href="trait.UiTaskWidget.html" title="trait zng::task::UiTaskWidget">UiTaskWidget</a></div><div class="desc docblock-short">Integrate <a href="struct.UiTask.html" title="struct zng::task::UiTask"><code>UiTask</code></a> with widget updates.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.block_on.html" title="fn zng::task::block_on">block_on</a></div><div class="desc docblock-short">Blocks the thread until the <code>task</code> future finishes.</div></li><li><div class="item-name"><a class="fn" href="fn.deadline.html" title="fn zng::task::deadline">deadline</a></div><div class="desc docblock-short">A future that is <a href="https://doc.rust-lang.org/1.80.1/core/task/poll/enum.Poll.html#variant.Pending" title="variant core::task::poll::Poll::Pending"><code>Pending</code></a> until the <code>deadline</code> is reached.</div></li><li><div class="item-name"><a class="fn" href="fn.doc_test.html" title="fn zng::task::doc_test">doc_test</a></div><div class="desc docblock-short">Executor used in async doc tests.</div></li><li><div class="item-name"><a class="fn" href="fn.future_fn.html" title="fn zng::task::future_fn">future_fn</a></div><div class="desc docblock-short">Implements a <a href="https://doc.rust-lang.org/1.80.1/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> from a closure.</div></li><li><div class="item-name"><a class="fn" href="fn.join.html" title="fn zng::task::join">join</a></div><div class="desc docblock-short">Rayon join with local context.</div></li><li><div class="item-name"><a class="fn" href="fn.join_context.html" title="fn zng::task::join_context">join_context</a></div><div class="desc docblock-short">Rayon join context with local context.</div></li><li><div class="item-name"><a class="fn" href="fn.poll_respond.html" title="fn zng::task::poll_respond">poll_respond</a></div><div class="desc docblock-short">Polls the <code>task</code> once immediately on the calling thread, if the <code>task</code> is ready returns the response already set,
if the <code>task</code> is pending continues execution like <a href="fn.respond.html" title="fn zng::task::respond"><code>respond</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.poll_spawn.html" title="fn zng::task::poll_spawn">poll_spawn</a></div><div class="desc docblock-short">Polls the <code>task</code> once immediately on the calling thread, if the <code>task</code> is pending, continues execution in <a href="fn.spawn.html" title="fn zng::task::spawn"><code>spawn</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.respond.html" title="fn zng::task::respond">respond</a></div><div class="desc docblock-short">Spawn a parallel async task that will send its result to a <a href="../var/type.ResponseVar.html" title="type zng::var::ResponseVar"><code>ResponseVar&lt;R&gt;</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.run.html" title="fn zng::task::run">run</a></div><div class="desc docblock-short">Spawn a parallel async task that can also be <code>.await</code> for the task result.</div></li><li><div class="item-name"><a class="fn" href="fn.run_catch.html" title="fn zng::task::run_catch">run_catch</a></div><div class="desc docblock-short">Like <a href="fn.run.html" title="fn zng::task::run"><code>run</code></a> but catches panics.</div></li><li><div class="item-name"><a class="fn" href="fn.scope.html" title="fn zng::task::scope">scope</a></div><div class="desc docblock-short">Rayon scope with local context.</div></li><li><div class="item-name"><a class="fn" href="fn.spawn.html" title="fn zng::task::spawn">spawn</a></div><div class="desc docblock-short">Spawn a parallel async task, this function is not blocking and the <code>task</code> starts executing immediately.</div></li><li><div class="item-name"><a class="fn" href="fn.spawn_wait.html" title="fn zng::task::spawn_wait">spawn_wait</a></div><div class="desc docblock-short">Fire and forget a <a href="fn.wait.html" title="fn zng::task::wait"><code>wait</code></a> task. The <code>task</code> starts executing immediately.</div></li><li><div class="item-name"><a class="fn" href="fn.spin_on.html" title="fn zng::task::spin_on">spin_on</a></div><div class="desc docblock-short">Continuous poll the <code>task</code> until if finishes.</div></li><li><div class="item-name"><a class="fn" href="fn.wait.html" title="fn zng::task::wait">wait</a></div><div class="desc docblock-short">Create a parallel <code>task</code> that blocks awaiting for an IO operation, the <code>task</code> starts on the first <code>.await</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.wait_catch.html" title="fn zng::task::wait_catch">wait_catch</a></div><div class="desc docblock-short">Like <a href="fn.wait.html" title="fn zng::task::wait"><code>wait</code></a> but catches panics.</div></li><li><div class="item-name"><a class="fn" href="fn.wait_respond.html" title="fn zng::task::wait_respond">wait_respond</a></div><div class="desc docblock-short">Like <a href="fn.spawn_wait.html" title="fn zng::task::spawn_wait"><code>spawn_wait</code></a>, but the task will send its result to a <a href="../var/type.ResponseVar.html" title="type zng::var::ResponseVar"><code>ResponseVar&lt;R&gt;</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.with_deadline.html" title="fn zng::task::with_deadline">with_deadline</a></div><div class="desc docblock-short">Add a <a href="fn.deadline.html" title="fn zng::task::deadline"><code>deadline</code></a> to a future.</div></li><li><div class="item-name"><a class="fn" href="fn.yield_now.html" title="fn zng::task::yield_now">yield_now</a></div><div class="desc docblock-short">A future that is <a href="https://doc.rust-lang.org/1.80.1/core/task/poll/enum.Poll.html#variant.Pending" title="variant core::task::poll::Poll::Pending"><code>Pending</code></a> once and wakes the current task.</div></li></ul></section></div></main></body></html>
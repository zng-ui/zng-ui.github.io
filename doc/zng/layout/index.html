<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Layout service, units and other types."><title>zng::layout - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="zng" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo-icon.png"><link rel="stylesheet" href="/doc/zng-material-icons-extensions.css">
</head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../zng/index.html"><img src="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../zng/index.html"><img src="https://raw.githubusercontent.com/zng-ui/zng/main/examples/image/res/zng-logo.png" alt="logo"></a><h2><a href="../../zng/index.html">zng</a><span class="version">0.12.1</span></h2></div><h2 class="location"><a href="#">Module layout</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#statics">Statics</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In crate zng</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">zng</a>::<wbr><a class="mod" href="#">layout</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/zng/layout.rs.html#1-382">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Layout service, units and other types.</p>
<p>A widget final size and position is influenced by the widget and all ancestor widgets, the properties
and nodes that influence the size and position can be grouped into <a href="#widget-intrinsics">widget intrinsics</a>,
<a href="#widget-properties">widget properties</a>, <a href="#layout-properties">layout properties</a> and <a href="#transform-properties">transform properties</a>.</p>
<p>Internally this is split into two passes <a href="../widget/node/trait.UiNode.html#tymethod.layout" title="method zng::widget::node::UiNode::layout"><code>UiNode::layout</code></a> and <a href="../widget/node/trait.UiNode.html#tymethod.render" title="method zng::widget::node::UiNode::render"><code>UiNode::render</code></a>, transform properties are only applied
during render and only influence the size and position of the widget and descendants, the other properties are true layout
and influence the size and position of the parent widget and siblings too.</p>
<h3 id="widget-intrinsics"><a class="doc-anchor" href="#widget-intrinsics">§</a>Widget Intrinsics</h3>
<p>Each widget defines a size preference, the default widget has no minimum nor maximum size, it fills available space and collapses
to zero when aligned, most widgets override this and have a minimum size preference.
The <code>Text!</code> prefers a size that fits the entire text without introducing wrap line breaks,
the <code>Stack!</code> widget prefers a size that fits all its children positioned in a given direction.</p>
<h4 id="widget-properties"><a class="doc-anchor" href="#widget-properties">§</a>Widget Properties</h4>
<p>Widget size can be influenced by properties widget specific properties, the <code>Text!</code> widget is affected by the font properties
for example, as different fonts have different sizes. The <code>Stack!</code> widget is affected by the <code>direction</code> property that changes
position of children widgets and so changes the size that best fits the children.</p>
<h3 id="layout-properties"><a class="doc-anchor" href="#layout-properties">§</a>Layout Properties</h3>
<p>Widget size and position can be more directly configured using the standalone layout properties defined in this module,
as an example the <a href="fn.min_size.html" title="fn zng::layout::min_size"><code>min_size</code></a> property influences the widget size and the <a href="fn.align.html" title="fn zng::layout::align"><code>align</code></a> property
influences the widget position, the <a href="fn.margin.html" title="fn zng::layout::margin"><code>margin</code></a> property potentially influences both size and position.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zng::prelude::<span class="kw-2">*</span>;

<span class="macro">Window!</span> {
    child = <span class="macro">Wgt!</span> {
        layout::min_size = <span class="number">40</span>;
        layout::align = layout::Align::CENTER;
        widget::background_color = colors::AZURE;
    };
}</code></pre></div>
<h3 id="transform-properties"><a class="doc-anchor" href="#transform-properties">§</a>Transform Properties</h3>
<p>Widget size and position can be affected during render only, the standalone <a href="fn.transform.html" title="fn zng::layout::transform"><code>transform</code></a> property
and derived properties like <a href="fn.scale.html" title="fn zng::layout::scale"><code>scale</code></a> change the final size and position of the widget by transforming
the final layout size and position, this affects only the widget and descendants, widget interactions like clicks
will <em>see</em> the widget at its final transformed bounds, but the parent widget will size itself and position other
children using the layout size and position.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zng::prelude::<span class="kw-2">*</span>;

<span class="macro">Stack!</span> {
    layout::align = layout::Align::CENTER;
    direction = StackDirection::left_to_right();
    children = <span class="macro">ui_vec!</span>[
        <span class="macro">Wgt!</span> {
            layout::size = (<span class="number">100</span>, <span class="number">200</span>);
            widget::background_color = colors::RED;
        },
        <span class="macro">Wgt!</span> {
            layout::scale = <span class="number">120</span>.pct();
            layout::size = (<span class="number">100</span>, <span class="number">200</span>);
            widget::z_index = widget::ZIndex::FRONT;
            widget::background_color = colors::GREEN;
        },
        <span class="macro">Wgt!</span> {
            layout::size = (<span class="number">100</span>, <span class="number">200</span>);
            widget::background_color = colors::BLUE;
        },
    ];
}</code></pre></div>
<p>The example above declares a horizontal stack with 3 rectangles, the green rectangle is rendered
slightly over the other rectangles because it is <a href="fn.scale.html" title="fn zng::layout::scale"><code>scale</code></a> to 120% of the size, scale
is a render transform only so the stack widget still positions the other rectangles as if the middle
one was not scaled. Also note the <a href="../widget/fn.z_index.html" title="fn zng::widget::z_index"><code>widget::z_index</code></a> usage, the stack widget
render each children in declaration order by default, this is overridden for the green rectangle so
it is rendered last, over the blue rectangle too.</p>
<h2 id="layout-units"><a class="doc-anchor" href="#layout-units">§</a>Layout Units</h2>
<p>Most layout properties receive inputs in <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> or length composite types like <a href="struct.Size.html" title="struct zng::layout::Size"><code>Size</code></a>. These
types are layout in the widget context to compute their actual length, the example below demonstrates
every <a href="trait.LengthUnits.html" title="trait zng::layout::LengthUnits"><code>LengthUnits</code></a>, <a href="trait.FactorUnits.html" title="trait zng::layout::FactorUnits"><code>FactorUnits</code></a> and length expressions.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zng::prelude::<span class="kw-2">*</span>;

<span class="macro">macro_rules!</span> width {
    (<span class="macro-nonterminal">$width</span>:expr) =&gt; {
        <span class="macro">Text!</span> {
            layout::force_width = <span class="macro-nonterminal">$width</span>;
            txt = <span class="macro">stringify!</span>(<span class="macro-nonterminal">$width</span>);
            widget::background_color = colors::BLUE.desaturate(<span class="number">50</span>.pct());
        }
    };
}
<span class="macro">Window!</span> {
    child_align = layout::Align::START;
    child = <span class="macro">Scroll!</span> {
        mode = zng::scroll::ScrollMode::VERTICAL;
        padding = <span class="number">10</span>;
        child = <span class="macro">Stack!</span> {
            direction = StackDirection::top_to_bottom();
            spacing = <span class="number">2</span>;
            children = <span class="macro">ui_vec!</span>[
                <span class="macro">width!</span>(<span class="number">100</span>), <span class="comment">// 100 device independent pixels
                </span><span class="macro">width!</span>(<span class="number">100</span>.dip()), <span class="comment">// 100 device independent pixels
                </span><span class="macro">width!</span>(<span class="number">100</span>.px()), <span class="comment">// 100 device pixels
                </span><span class="macro">width!</span>(<span class="number">100</span>.pct()), <span class="comment">// 100% of the available width
                </span><span class="macro">width!</span>(<span class="number">100</span>.pct_l()), <span class="comment">// 100% of the available width
                </span><span class="macro">width!</span>(<span class="number">50</span>.pct()), <span class="comment">// 50% of the available width
                </span><span class="macro">width!</span>(<span class="number">1</span>.fct()), <span class="comment">// 1 times the available width
                </span><span class="macro">width!</span>(<span class="number">1</span>.fct_l()), <span class="comment">// 1 times the available width
                </span><span class="macro">width!</span>(<span class="number">0.5</span>.fct()), <span class="comment">// 0.5 times the available width
                </span><span class="macro">width!</span>(<span class="number">100</span>.pt()), <span class="comment">// 100 font points
                </span><span class="macro">width!</span>(<span class="number">8</span>.em()), <span class="comment">// 8 times the font size
                </span><span class="macro">width!</span>(<span class="number">800</span>.em_pct()), <span class="comment">// 800% of the font size
                </span><span class="macro">width!</span>(<span class="number">8</span>.rem()), <span class="comment">// 8 times the root font size
                </span><span class="macro">width!</span>(<span class="number">800</span>.rem_pct()), <span class="comment">// 800% of the root font size
                </span><span class="macro">width!</span>(<span class="number">1</span>.vw()), <span class="comment">// 1 times the viewport width
                </span><span class="macro">width!</span>(<span class="number">100</span>.vw_pct()), <span class="comment">// 100% of the viewport width
                </span><span class="macro">width!</span>(<span class="number">0.5</span>.vw()), <span class="comment">// 0.5 times the viewport width
                </span><span class="macro">width!</span>(<span class="number">1</span>.vh()), <span class="comment">// 1 times the viewport height
                </span><span class="macro">width!</span>(<span class="number">100</span>.vh_pct()), <span class="comment">// 100% of the viewport height
                </span><span class="macro">width!</span>(<span class="number">0.5</span>.vh()), <span class="comment">// 0.5 times the viewport height
                </span><span class="macro">width!</span>(<span class="number">0.5</span>.vmin()), <span class="comment">// 0.5 times the viewport min(width, height)
                </span><span class="macro">width!</span>(<span class="number">50</span>.vmin_pct()), <span class="comment">// 50% of the viewport min(width, height)
                </span><span class="macro">width!</span>(<span class="number">0.5</span>.vmax()), <span class="comment">// 0.5 times the viewport max(width, height)
                </span><span class="macro">width!</span>(<span class="number">50</span>.vmax_pct()), <span class="comment">// 50% of the viewport max(width, height)
                </span><span class="macro">width!</span>(<span class="number">100</span>.dip() + <span class="number">50</span>.pct()), <span class="comment">// expression, 100dip + 50%.
                </span><span class="macro">width!</span>(<span class="number">1</span>.lft()), <span class="comment">//1 parcel of the leftover space.
                </span><span class="macro">width!</span>(Length::Default), <span class="comment">// default value
            </span>];
            widget::border = <span class="number">1</span>, colors::RED.desaturate(<span class="number">50</span>.pct());
        };
    };
}</code></pre></div>
<h3 id="length--factor-units"><a class="doc-anchor" href="#length--factor-units">§</a>Length &amp; Factor Units</h3>
<p>Length units are defined by <a href="trait.LengthUnits.html" title="trait zng::layout::LengthUnits"><code>LengthUnits</code></a> that provides extension methods for <code>f32</code> and <code>i32</code> values.</p>
<p>The most common unit is the <em>device independent pixel</em>, or DIP, this is a value that is multiplied by the system scale
factor to compute the an exact pixel length, widgets sized in DIPs have a similar apparent size indented of the
screen pixel density. This is the default unit, <code>f32</code> and <code>i32</code> convert to it so <code>width = 100;</code> is the same as <code>width = 100.dip();</code>.</p>
<p>Length can be relative to the available space provided by the parent widget, <code>100.pct()</code> and <code>1.fct()</code> declare <a href="struct.FactorPercent.html" title="struct zng::layout::FactorPercent"><code>FactorPercent</code></a>
and <a href="struct.Factor.html" title="struct zng::layout::Factor"><code>Factor</code></a> values that convert to <a href="enum.Length.html#variant.Factor" title="variant zng::layout::Length::Factor"><code>Length::Factor</code></a>. The <a href="trait.FactorUnits.html" title="trait zng::layout::FactorUnits"><code>FactorUnits</code></a> provide the extension methods and
is implemented for <code>f32</code> and <code>i32</code>. You can also use <code>100.pct_l()</code> and <code>1.fct_l()</code> to get a <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> value directly in places
that don’t convert the factor types to length.</p>
<p>There are multiple units related to font size, <code>24.pt()</code> defines a size in <em>font points</em>, one font point is <code>96/72 * scale_factor</code>
device pixels. Size can be relative to the contextual font size, <code>2.em()</code> and <code>200.em_pct()</code> declare a length twice the computed
contextual font size, <code>2.rem()</code> and <code>2.rem_pct()</code> declare a length twice the computed root font size (the <code>Window!</code> font size).</p>
<p>Lengths can also be relative to the <em>viewport</em>. The viewport is the window content area size, or the parent <code>Scroll!</code> visible area size.
Lengths <code>0.2.vw()</code> and <code>20.vw_pct()</code> are 20% of the viewport width, <code>0.2.vh()</code> and <code>20.vh_pct()</code> are 20% of the viewport height,
<code>1.vmin()</code> is the minimum viewport length (<code>min(w, h)</code>), <code>1.vmax()</code> is the maximum viewport length.</p>
<h4 id="length-expressions"><a class="doc-anchor" href="#length-expressions">§</a>Length Expressions</h4>
<p>Different length units can be mixed into a length expression, <code>1.em() + 5.dip()</code> will create a <a href="enum.Length.html#variant.Expr" title="variant zng::layout::Length::Expr"><code>Length::Expr</code></a> value that on layout
will compute the pixel length of both terms and then sum. Length expressions support the four basic arithmetic operations, negation,
maximum and minimum and absolute.</p>
<p>Some basic length expressions are pre-computed on the spot, <code>10.dip() + 10.dip()</code> declares a <code>Length::Dip(20)</code> value, but most
expression declare an object that dynamically executes the expression after all terms are layout.</p>
<h4 id="leftover-length"><a class="doc-anchor" href="#leftover-length">§</a>Leftover Length</h4>
<p>The leftover length is a special value that represents the space leftover after non-leftover sibling widgets are layout. This
must be implemented by a parent widget to fully work, the <code>Grid!</code> widget implements it, in widgets that don’t implement it
the unit behaves like a factor.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zng::prelude::<span class="kw-2">*</span>;

<span class="macro">Window!</span> {
    child = <span class="macro">Grid!</span> {
        columns = <span class="macro">ui_vec!</span>[
            <span class="macro">grid::Column!</span>(<span class="number">1</span>.lft()),
            <span class="macro">grid::Column!</span>(<span class="number">100</span>.dip()),
            <span class="macro">grid::Column!</span>(<span class="number">2</span>.lft()),
        ];
        rows = <span class="macro">ui_vec!</span>[<span class="macro">grid::Row!</span>(<span class="number">100</span>.pct())];
        cells = <span class="macro">ui_vec!</span>[
            <span class="macro">Wgt!</span> {
                grid::cell::column = <span class="number">0</span>;
                widget::background_color = colors::RED;
            },
            <span class="macro">Wgt!</span> {
                grid::cell::column = <span class="number">1</span>;
                widget::background_color = colors::GREEN;
            },
            <span class="macro">Wgt!</span> {
                grid::cell::column = <span class="number">2</span>;
                widget::background_color = colors::BLUE;
            },
        ];
    }
}</code></pre></div>
<p>The example above declares a grid with 3 columns, on layout the grid computes the width of the middle column first (<code>100.dip()</code>),
the leftover available width is divided between the other 2 columns proportional to the leftover value. Note that value range
of leftover is normalized across all leftover siblings, in the example above changing the values to <code>2.lft()</code> and <code>4.lft()</code>
will produce the column sizes.</p>
<h4 id="default-length"><a class="doc-anchor" href="#default-length">§</a>Default Length</h4>
<p>The <a href="enum.Length.html#variant.Default" title="variant zng::layout::Length::Default"><code>Length::Default</code></a> value represents the length that is used when no other length is set. It is a placeholder value
that is filled in by the widget or property that is resolving the layout. The <code>grid::Column!()</code> has <code>Default</code> width, in
grids this means <em>auto-size</em>, the column is sized to fit all cells. In the standalone <a href="fn.width.html" title="fn zng::layout::width"><code>width</code></a> property
the default width means the fill width.</p>
<h2 id="measure--layout"><a class="doc-anchor" href="#measure--layout">§</a>Measure &amp; Layout</h2>
<p>Nodes that implement custom layout must handle <a href="../widget/node/trait.UiNode.html#tymethod.measure" title="method zng::widget::node::UiNode::measure"><code>UiNode::measure</code></a> and <a href="../widget/node/trait.UiNode.html#tymethod.layout" title="method zng::widget::node::UiNode::layout"><code>UiNode::layout</code></a>.
Measure and layout provide a desired size and final size respectively, given the same context both methods return the
same size, the different is that the measure call must not actually affect the widget, it exists to allow a parent widget
to query what the layout result would be for a given context.</p>
<p>Consider a <code>Stack!</code> that is aligned <code>CENTER</code> and has children aligned <code>FILL</code>, to fulfill these constraints
the stack does the layout in two passes, first it measures each child to find the width, then it layouts
each child constrained to this width. If this same stack is given an exact size it will skip the measure
pass and just do the layout directly.</p>
<p>The coordination between layout properties on a widget and between widgets is centered on the <a href="struct.LAYOUT.html" title="struct zng::layout::LAYOUT"><code>LAYOUT</code></a>, <a href="struct.WidgetMeasure.html" title="struct zng::layout::WidgetMeasure"><code>WidgetMeasure</code></a>,
<a href="struct.WidgetLayout.html" title="struct zng::layout::WidgetLayout"><code>WidgetLayout</code></a> and the return <a href="type.PxSize.html" title="type zng::layout::PxSize"><code>PxSize</code></a>. Parent nodes set context metrics and constraints using the <a href="struct.LAYOUT.html" title="struct zng::layout::LAYOUT"><code>LAYOUT</code></a> service,
child nodes returns the size and optionally set more return metadata in the <a href="struct.WidgetMeasure.html" title="struct zng::layout::WidgetMeasure"><code>WidgetMeasure</code></a> and <a href="struct.WidgetLayout.html" title="struct zng::layout::WidgetLayout"><code>WidgetLayout</code></a> args.
The parent node then sets the child position using <a href="struct.WidgetLayout.html" title="struct zng::layout::WidgetLayout"><code>WidgetLayout</code></a> or by manually transforming the child during render.</p>
<p>Other contextual services and variables may complement the layout computation, the <a href="struct.WIDGET_SIZE.html" title="struct zng::layout::WIDGET_SIZE"><code>WIDGET_SIZE</code></a> is used to implement
<a href="enum.Length.html#variant.Leftover" title="variant zng::layout::Length::Leftover"><code>Length::Leftover</code></a> layouts, the <a href="../widget/struct.BORDER.html" title="struct zng::widget::BORDER"><code>widget::BORDER</code></a> is used to implement the alignment between borders and the background.
Widgets can use context vars to define layout preferences that only apply to their special layout, the <code>Text!</code> and <code>Image!</code>
widgets are examples of this.</p>
<p>UI components are very modular, during layout is when they are the closest coupled, implementers must careful consider
the full <a href="struct.LAYOUT.html" title="struct zng::layout::LAYOUT"><code>LAYOUT</code></a>, <a href="struct.WidgetMeasure.html" title="struct zng::layout::WidgetMeasure"><code>WidgetMeasure</code></a> <a href="struct.WidgetLayout.html" title="struct zng::layout::WidgetLayout"><code>WidgetLayout</code></a> APIs, understand what properties placed in the <a href="../widget/builder/struct.NestGroup.html#associatedconstant.LAYOUT" title="associated constant zng::widget::builder::NestGroup::LAYOUT"><code>NestGroup::LAYOUT</code></a> can do
and what the widget outer and inner bounds are. Implementers also must consider if their layout will support inlining or
if it will only be a block. After reading the APIs a good way to learn is by studying the source code of properties in this
module, followed by the <code>Image!</code>, <code>Stack!</code>, <code>Grid!</code> and <code>Wrap!</code> implementations.</p>
<h3 id="outer--inner-bounds"><a class="doc-anchor" href="#outer--inner-bounds">§</a>Outer &amp; Inner Bounds</h3>
<p>Each laidout widget has two computed rectangles, the inner bounds define the rendered area, the outer bounds define
the extra space taken by the widget layout, properties like <a href="fn.align.html" title="fn zng::layout::align"><code>align</code></a> and <a href="fn.margin.html" title="fn zng::layout::margin"><code>margin</code></a> are still
a part of the widget, the blank space they add <em>around</em> the widget is inside the widget outer bounds.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zng::prelude::<span class="kw-2">*</span>;

<span class="macro">Window!</span> {
    padding = <span class="number">20</span>;
    child = <span class="macro">Wgt!</span> {
        layout::size = <span class="number">80</span>;
        layout::align = layout::Align::CENTER;
        window::inspector::show_bounds = <span class="bool-val">true</span>;
    };
}</code></pre></div>
<p>The example above uses the <a href="../window/inspector/fn.show_bounds.html" title="fn zng::window::inspector::show_bounds"><code>window::inspector::show_bounds</code></a> property to inspect the bounds of a widget, it shows the
outer bounds of the widget extend to almost cover the entire window, that happens because the window default <code>child_align</code> is
<code>FILL</code> and it only reserved <code>20</code> of padding space, leaving the rest of the space for the child widget to handle. The widget
wants to have an exact size of <code>80</code> centered on the available space, so it ends up with the outer bounds taking the available space
and the inner bounds taking the exact size.</p>
<h3 id="inline"><a class="doc-anchor" href="#inline">§</a>Inline</h3>
<p>Layout has two modes, blocks and inline, in block layout the shape of the laidout widgets is not changed, they are always
rectangular, inline layout expands layout to alter the shape of laidout widgets to potentially split into multiple rectangles that
define the first line, the middle block of lines and the last line.</p>
<p>The example below declares a <code>Wrap!</code> with 3 <code>Text!</code> children, both the wrap and text widgets support inline layout so the end-result
is that the green text will be reshaped as two rectangles, one after the red text and one before the blue text.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zng::prelude::<span class="kw-2">*</span>;

<span class="macro">Wrap!</span> {
    children = <span class="macro">ui_vec!</span>[
        <span class="macro">Text!</span> {
            widget::background_color = colors::RED.with_alpha(<span class="number">40</span>.pct());
            txt = <span class="string">"RED"</span>;
        },
        <span class="macro">Text!</span> {
            widget::background_color = colors::GREEN.with_alpha(<span class="number">40</span>.pct());
            txt = <span class="string">"GREEN\nGREEN"</span>;
        },
        <span class="macro">Text!</span> {
            widget::background_color = colors::BLUE.with_alpha(<span class="number">40</span>.pct());
            txt = <span class="string">"BLUE"</span>;
        },
    ]
}</code></pre></div>
<p>Inline layout is modeled to support complex text layout interactions, like bidirectional text reordering, inlined widgets don’t need
to be text however, the <code>Wrap!</code> widget itself can be nested.</p>
<p>If a widget does not support inline it calls <a href="struct.WidgetMeasure.html#method.disable_inline" title="method zng::layout::WidgetMeasure::disable_inline"><code>WidgetMeasure::disable_inline</code></a>, in an inline context these widgets
are <em>inline-blocks</em>. If a panel widget does not support inline and it needs to measure children it calls <a href="struct.WidgetMeasure.html#method.measure_block" title="method zng::layout::WidgetMeasure::measure_block"><code>WidgetMeasure::measure_block</code></a>.</p>
<p>If a widget or property supports inline it can detect it is in an inline context by <a href="struct.WidgetMeasure.html#method.inline" title="method zng::layout::WidgetMeasure::inline"><code>WidgetMeasure::inline</code></a> where the preferred
segments of the widget can be set for the parent inline panel to analyze, if inline is set during measure it will also be inline
during layout and <a href="struct.LAYOUT.html" title="struct zng::layout::LAYOUT"><code>LAYOUT</code></a> will have inline constraints. During layout the <a href="struct.WidgetLayout.html#method.inline" title="method zng::layout::WidgetLayout::inline"><code>WidgetLayout::inline</code></a> value can
be set to the final inline info.</p>
<p>After inline layout the are positioned so that the last line of the previous sibling connects with the first line of the next, all
of the widget visual properties must support this however, the <a href="../widget/info/struct.WidgetBoundsInfo.html#method.inline" title="method zng::widget::info::WidgetBoundsInfo::inline"><code>WIDGET.bounds().inline()</code></a> is available during render with cached
negative space clips that can quickly be used. If a visual property is not aware of inline it can potentially render over the
previous sibling, inline should be disabled for the widget if the property cannot support inline.</p>
<h2 id="full-api"><a class="doc-anchor" href="#full-api">§</a>Full API</h2>
<p>See <a href="../../zng_layout/index.html" title="mod zng_layout"><code>zng_layout</code></a>, <a href="../../zng_wgt_transform/index.html" title="mod zng_wgt_transform"><code>zng_wgt_transform</code></a> and <a href="../../zng_wgt_size_offset/index.html" title="mod zng_wgt_size_offset"><code>zng_wgt_size_offset</code></a> for the full API.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Align.html" title="struct zng::layout::Align">Align</a></div><div class="desc docblock-short"><code>x</code> and <code>y</code> alignment.</div></li><li><div class="item-name"><a class="struct" href="struct.AngleDegree.html" title="struct zng::layout::AngleDegree">AngleDegree</a></div><div class="desc docblock-short">Angle in degrees.</div></li><li><div class="item-name"><a class="struct" href="struct.AngleGradian.html" title="struct zng::layout::AngleGradian">AngleGradian</a></div><div class="desc docblock-short">Angle in gradians.</div></li><li><div class="item-name"><a class="struct" href="struct.AngleRadian.html" title="struct zng::layout::AngleRadian">AngleRadian</a></div><div class="desc docblock-short">Angle in radians.</div></li><li><div class="item-name"><a class="struct" href="struct.AngleTurn.html" title="struct zng::layout::AngleTurn">AngleTurn</a></div><div class="desc docblock-short">Angle in turns (complete rotations).</div></li><li><div class="item-name"><a class="struct" href="struct.BoolVector2D.html" title="struct zng::layout::BoolVector2D">BoolVector2D</a></div><div class="desc docblock-short">A 2d vector of booleans, useful for component-wise logic operations.</div></li><li><div class="item-name"><a class="struct" href="struct.ByteLength.html" title="struct zng::layout::ByteLength">ByteLength</a></div><div class="desc docblock-short">A length in bytes.</div></li><li><div class="item-name"><a class="struct" href="struct.CornerRadius2D.html" title="struct zng::layout::CornerRadius2D">CornerRadius2D</a></div><div class="desc docblock-short">Ellipses that define the radius of the four corners of a 2D box.</div></li><li><div class="item-name"><a class="struct" href="struct.Dip.html" title="struct zng::layout::Dip">Dip</a></div><div class="desc docblock-short">Device independent pixel.</div></li><li><div class="item-name"><a class="struct" href="struct.DistanceKey.html" title="struct zng::layout::DistanceKey">DistanceKey</a></div><div class="desc docblock-short">Comparable key that represents the absolute distance between two pixel points.</div></li><li><div class="item-name"><a class="struct" href="struct.Factor.html" title="struct zng::layout::Factor">Factor</a></div><div class="desc docblock-short">Normalized multiplication factor.</div></li><li><div class="item-name"><a class="struct" href="struct.Factor2d.html" title="struct zng::layout::Factor2d">Factor2d</a></div><div class="desc docblock-short">Scale factor applied to <em><strong>x</strong></em> and <em><strong>y</strong></em> dimensions.</div></li><li><div class="item-name"><a class="struct" href="struct.FactorPercent.html" title="struct zng::layout::FactorPercent">FactorPercent</a></div><div class="desc docblock-short">Multiplication factor in percentage (0%-100%).</div></li><li><div class="item-name"><a class="struct" href="struct.FactorSideOffsets.html" title="struct zng::layout::FactorSideOffsets">FactorSideOffsets</a></div><div class="desc docblock-short">Scale factor applied to margins.</div></li><li><div class="item-name"><a class="struct" href="struct.GridSpacing.html" title="struct zng::layout::GridSpacing">GridSpacing</a></div><div class="desc docblock-short">Spacing in-between grid cells in <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> units.</div></li><li><div class="item-name"><a class="struct" href="struct.InlineConstraintsLayout.html" title="struct zng::layout::InlineConstraintsLayout">InlineConstraintsLayout</a></div><div class="desc docblock-short">Constraints for inline layout.</div></li><li><div class="item-name"><a class="struct" href="struct.InlineConstraintsMeasure.html" title="struct zng::layout::InlineConstraintsMeasure">InlineConstraintsMeasure</a></div><div class="desc docblock-short">Constraints for inline measure.</div></li><li><div class="item-name"><a class="struct" href="struct.InlineSegment.html" title="struct zng::layout::InlineSegment">InlineSegment</a></div><div class="desc docblock-short">Represents a segment in an inlined widget first or last row.</div></li><li><div class="item-name"><a class="struct" href="struct.InlineSegmentPos.html" title="struct zng::layout::InlineSegmentPos">InlineSegmentPos</a></div><div class="desc docblock-short">Position of an inline segment set by the inlining parent.</div></li><li><div class="item-name"><a class="struct" href="struct.LAYOUT.html" title="struct zng::layout::LAYOUT">LAYOUT</a></div><div class="desc docblock-short">Current layout context.</div></li><li><div class="item-name"><a class="struct" href="struct.LayoutMask.html" title="struct zng::layout::LayoutMask">LayoutMask</a></div><div class="desc docblock-short">Mask of values that can affect the layout operation of a value.</div></li><li><div class="item-name"><a class="struct" href="struct.LayoutMetrics.html" title="struct zng::layout::LayoutMetrics">LayoutMetrics</a></div><div class="desc docblock-short">Layout metrics in a <a href="struct.LAYOUT.html" title="struct zng::layout::LAYOUT"><code>LAYOUT</code></a> context.</div></li><li><div class="item-name"><a class="struct" href="struct.LayoutMetricsSnapshot.html" title="struct zng::layout::LayoutMetricsSnapshot">LayoutMetricsSnapshot</a></div><div class="desc docblock-short">Layout metrics snapshot.</div></li><li><div class="item-name"><a class="struct" href="struct.LayoutPassId.html" title="struct zng::layout::LayoutPassId">LayoutPassId</a></div><div class="desc docblock-short">Identifies the layout pass of a window.</div></li><li><div class="item-name"><a class="struct" href="struct.Line.html" title="struct zng::layout::Line">Line</a></div><div class="desc docblock-short">2D line in <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> units.</div></li><li><div class="item-name"><a class="struct" href="struct.Point.html" title="struct zng::layout::Point">Point</a></div><div class="desc docblock-short">2D point in <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> units.</div></li><li><div class="item-name"><a class="struct" href="struct.Ppi.html" title="struct zng::layout::Ppi">Ppi</a></div><div class="desc docblock-short">Pixels-per-inch resolution.</div></li><li><div class="item-name"><a class="struct" href="struct.Ppm.html" title="struct zng::layout::Ppm">Ppm</a></div><div class="desc docblock-short">Pixels-per-meter resolution.</div></li><li><div class="item-name"><a class="struct" href="struct.Px.html" title="struct zng::layout::Px">Px</a></div><div class="desc docblock-short">Device pixel.</div></li><li><div class="item-name"><a class="struct" href="struct.PxConstraints.html" title="struct zng::layout::PxConstraints">PxConstraints</a></div><div class="desc docblock-short">Pixel length constraints.</div></li><li><div class="item-name"><a class="struct" href="struct.PxConstraints2d.html" title="struct zng::layout::PxConstraints2d">PxConstraints2d</a></div><div class="desc docblock-short">Pixel <em>size</em> constraints.</div></li><li><div class="item-name"><a class="struct" href="struct.PxGridSpacing.html" title="struct zng::layout::PxGridSpacing">PxGridSpacing</a></div><div class="desc docblock-short">Computed <a href="struct.GridSpacing.html" title="struct zng::layout::GridSpacing"><code>GridSpacing</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.PxLine.html" title="struct zng::layout::PxLine">PxLine</a></div><div class="desc docblock-short">Computed <a href="struct.Line.html" title="struct zng::layout::Line"><code>Line</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Rect.html" title="struct zng::layout::Rect">Rect</a></div><div class="desc docblock-short">2D rect in <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> units.</div></li><li><div class="item-name"><a class="struct" href="struct.SideOffsets.html" title="struct zng::layout::SideOffsets">SideOffsets</a></div><div class="desc docblock-short">2D size offsets in <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> units.</div></li><li><div class="item-name"><a class="struct" href="struct.SideOffsets2D.html" title="struct zng::layout::SideOffsets2D">SideOffsets2D</a></div><div class="desc docblock-short">A group of 2D side offsets, which correspond to top/right/bottom/left for borders, padding,
and margins in CSS, optionally tagged with a unit.</div></li><li><div class="item-name"><a class="struct" href="struct.Size.html" title="struct zng::layout::Size">Size</a></div><div class="desc docblock-short">2D size in <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> units.</div></li><li><div class="item-name"><a class="struct" href="struct.Transform.html" title="struct zng::layout::Transform">Transform</a></div><div class="desc docblock-short">A transform builder type.</div></li><li><div class="item-name"><a class="struct" href="struct.Vector.html" title="struct zng::layout::Vector">Vector</a></div><div class="desc docblock-short">2D vector in <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> units.</div></li><li><div class="item-name"><a class="struct" href="struct.WIDGET_SIZE.html" title="struct zng::layout::WIDGET_SIZE">WIDGET_SIZE</a></div><div class="desc docblock-short">Exact size property info.</div></li><li><div class="item-name"><a class="struct" href="struct.WidgetLayout.html" title="struct zng::layout::WidgetLayout">WidgetLayout</a></div><div class="desc docblock-short">Represents the in-progress layout pass for a widget tree.</div></li><li><div class="item-name"><a class="struct" href="struct.WidgetMeasure.html" title="struct zng::layout::WidgetMeasure">WidgetMeasure</a></div><div class="desc docblock-short">Represents the in-progress measure pass for a widget tree.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.InlineConstraints.html" title="enum zng::layout::InlineConstraints">InlineConstraints</a></div><div class="desc docblock-short">Constraints for inline measure or layout.</div></li><li><div class="item-name"><a class="enum" href="enum.InlineMode.html" title="enum zng::layout::InlineMode">InlineMode</a></div><div class="desc docblock-short">Inline mode explicitly selected for a widget.</div></li><li><div class="item-name"><a class="enum" href="enum.LayoutAxis.html" title="enum zng::layout::LayoutAxis">LayoutAxis</a></div><div class="desc docblock-short">Represents a layout dimension.</div></li><li><div class="item-name"><a class="enum" href="enum.LayoutDirection.html" title="enum zng::layout::LayoutDirection">LayoutDirection</a></div><div class="desc docblock-short">Defines the layout flow direction.</div></li><li><div class="item-name"><a class="enum" href="enum.Length.html" title="enum zng::layout::Length">Length</a></div><div class="desc docblock-short">1D length units.</div></li><li><div class="item-name"><a class="enum" href="enum.LengthExpr.html" title="enum zng::layout::LengthExpr">LengthExpr</a></div><div class="desc docblock-short">Represents an unresolved <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> expression.</div></li><li><div class="item-name"><a class="enum" href="enum.Orientation2D.html" title="enum zng::layout::Orientation2D">Orientation2D</a></div><div class="desc docblock-short">Orientation of two 2D items.</div></li><li><div class="item-name"><a class="enum" href="enum.PxTransform.html" title="enum zng::layout::PxTransform">PxTransform</a></div><div class="desc docblock-short">A transform in device pixels.</div></li><li><div class="item-name"><a class="enum" href="enum.TextSegmentKind.html" title="enum zng::layout::TextSegmentKind">TextSegmentKind</a></div><div class="desc docblock-short">The type of an inline/text segment.</div></li><li><div class="item-name"><a class="enum" href="enum.TransformStyle.html" title="enum zng::layout::TransformStyle">TransformStyle</a></div><div class="desc docblock-short">Defines if a widget is part of the same 3D space as the parent.</div></li><li><div class="item-name"><a class="enum" href="enum.WidgetLength.html" title="enum zng::layout::WidgetLength">WidgetLength</a></div><div class="desc docblock-short">Represents the width or height property value set on a widget.</div></li></ul><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="static" href="static.DIRECTION_VAR.html" title="static zng::layout::DIRECTION_VAR">DIRECTION_VAR</a></div><div class="desc docblock-short">Wrap direction of text in a widget context.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AngleUnits.html" title="trait zng::layout::AngleUnits">AngleUnits</a></div><div class="desc docblock-short">Extension methods for initializing angle units.</div></li><li><div class="item-name"><a class="trait" href="trait.ByteUnits.html" title="trait zng::layout::ByteUnits">ByteUnits</a></div><div class="desc docblock-short">Extension methods for initializing <a href="struct.ByteLength.html" title="struct zng::layout::ByteLength"><code>ByteLength</code></a> values.</div></li><li><div class="item-name"><a class="trait" href="trait.DipToPx.html" title="trait zng::layout::DipToPx">DipToPx</a></div><div class="desc docblock-short">Conversion from <a href="struct.Dip.html" title="struct zng::layout::Dip"><code>Dip</code></a> to <a href="struct.Px.html" title="struct zng::layout::Px"><code>Px</code></a> units.</div></li><li><div class="item-name"><a class="trait" href="trait.FactorUnits.html" title="trait zng::layout::FactorUnits">FactorUnits</a></div><div class="desc docblock-short">Extension methods for initializing factor units.</div></li><li><div class="item-name"><a class="trait" href="trait.Layout1d.html" title="trait zng::layout::Layout1d">Layout1d</a></div><div class="desc docblock-short">Represents a one-dimensional length value that can be converted to a pixel length in a <a href="struct.LAYOUT.html" title="struct zng::layout::LAYOUT"><code>LAYOUT</code></a> context.</div></li><li><div class="item-name"><a class="trait" href="trait.Layout2d.html" title="trait zng::layout::Layout2d">Layout2d</a></div><div class="desc docblock-short">Represents a two-dimensional value that can be converted to a pixel value in a <a href="struct.LAYOUT.html" title="struct zng::layout::LAYOUT"><code>LAYOUT</code></a> context.</div></li><li><div class="item-name"><a class="trait" href="trait.LengthUnits.html" title="trait zng::layout::LengthUnits">LengthUnits</a></div><div class="desc docblock-short">Extension methods for initializing <a href="enum.Length.html" title="enum zng::layout::Length"><code>Length</code></a> units.</div></li><li><div class="item-name"><a class="trait" href="trait.LineFromTuplesBuilder.html" title="trait zng::layout::LineFromTuplesBuilder">LineFromTuplesBuilder</a></div><div class="desc docblock-short">Build a <a href="struct.Line.html" title="struct zng::layout::Line"><code>Line</code></a> using the syntax <code>(x1, y1).to(x2, y2)</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.PxToDip.html" title="trait zng::layout::PxToDip">PxToDip</a></div><div class="desc docblock-short">Conversion from <a href="struct.Px.html" title="struct zng::layout::Px"><code>Px</code></a> to <a href="struct.Dip.html" title="struct zng::layout::Dip"><code>Dip</code></a> units.</div></li><li><div class="item-name"><a class="trait" href="trait.RectFromTuplesBuilder.html" title="trait zng::layout::RectFromTuplesBuilder">RectFromTuplesBuilder</a></div><div class="desc docblock-short">Build a <a href="struct.Rect.html" title="struct zng::layout::Rect"><code>Rect</code></a> using the syntax <code>(width, height).at(x, y)</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.ResolutionUnits.html" title="trait zng::layout::ResolutionUnits">ResolutionUnits</a></div><div class="desc docblock-short">Extension methods for initializing resolution units.</div></li><li><div class="item-name"><a class="trait" href="trait.TimeUnits.html" title="trait zng::layout::TimeUnits">TimeUnits</a></div><div class="desc docblock-short">Extension methods for initializing <a href="https://doc.rust-lang.org/1.81.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>Duration</code></a> values.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.actual_bounds.html" title="fn zng::layout::actual_bounds">actual_bounds</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Getter property, gets the latest rendered widget inner bounds in the window space.</div></li><li><div class="item-name"><a class="fn" href="fn.actual_height.html" title="fn zng::layout::actual_height">actual_height</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Getter property, gets the latest rendered widget inner height.</div></li><li><div class="item-name"><a class="fn" href="fn.actual_height_px.html" title="fn zng::layout::actual_height_px">actual_height_px</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Getter property, gets the latest rendered widget inner height, in device pixels.</div></li><li><div class="item-name"><a class="fn" href="fn.actual_size.html" title="fn zng::layout::actual_size">actual_size</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Getter property, gets the latest rendered widget inner size.</div></li><li><div class="item-name"><a class="fn" href="fn.actual_size_px.html" title="fn zng::layout::actual_size_px">actual_size_px</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Getter property, gets the latest rendered widget inner size, in device pixels.</div></li><li><div class="item-name"><a class="fn" href="fn.actual_transform.html" title="fn zng::layout::actual_transform">actual_transform</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Getter property, gets the latest rendered widget inner transform.</div></li><li><div class="item-name"><a class="fn" href="fn.actual_width.html" title="fn zng::layout::actual_width">actual_width</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Getter property, gets the latest rendered widget inner width.</div></li><li><div class="item-name"><a class="fn" href="fn.actual_width_px.html" title="fn zng::layout::actual_width_px">actual_width_px</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Getter property, gets the latest rendered widget inner width, in device pixels.</div></li><li><div class="item-name"><a class="fn" href="fn.align.html" title="fn zng::layout::align">align</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Aligns the widget within the available space.</div></li><li><div class="item-name"><a class="fn" href="fn.backface_visibility.html" title="fn zng::layout::backface_visibility">backface_visibility</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Sets if the widget is still visible when it is turned back towards the viewport due to rotations in X or Y axis in
the widget or in parent widgets.</div></li><li><div class="item-name"><a class="fn" href="fn.baseline.html" title="fn zng::layout::baseline">baseline</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Set or overwrite the baseline of the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.child_align.html" title="fn zng::layout::child_align">child_align</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Aligns the widget <em>content</em> within the available space.</div></li><li><div class="item-name"><a class="fn" href="fn.force_height.html" title="fn zng::layout::force_height">force_height</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Exact height of the widget ignoring the contextual max.</div></li><li><div class="item-name"><a class="fn" href="fn.force_size.html" title="fn zng::layout::force_size">force_size</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Exact size of the widget ignoring the contextual max.</div></li><li><div class="item-name"><a class="fn" href="fn.force_width.html" title="fn zng::layout::force_width">force_width</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Exact width of the widget ignoring the contextual max.</div></li><li><div class="item-name"><a class="fn" href="fn.height.html" title="fn zng::layout::height">height</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Exact height of the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.inline.html" title="fn zng::layout::inline">inline</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Enforce an inline mode on the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.is_ltr.html" title="fn zng::layout::is_ltr">is_ltr</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  If the layout direction is left-to-right.</div></li><li><div class="item-name"><a class="fn" href="fn.is_rtl.html" title="fn zng::layout::is_rtl">is_rtl</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  If the layout direction is right-to-left.</div></li><li><div class="item-name"><a class="fn" href="fn.margin.html" title="fn zng::layout::margin">margin</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Margin space around the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.max_height.html" title="fn zng::layout::max_height">max_height</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Maximum height of the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.max_size.html" title="fn zng::layout::max_size">max_size</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Maximum size of the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.max_width.html" title="fn zng::layout::max_width">max_width</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Maximum width of the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.min_height.html" title="fn zng::layout::min_height">min_height</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Minimum height of the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.min_size.html" title="fn zng::layout::min_size">min_size</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Minimum size of the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.min_width.html" title="fn zng::layout::min_width">min_width</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Minimum width of the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.offset.html" title="fn zng::layout::offset">offset</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Widget layout offset.</div></li><li><div class="item-name"><a class="fn" href="fn.padding.html" title="fn zng::layout::padding">padding</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Margin space around the content of a widget.</div></li><li><div class="item-name"><a class="fn" href="fn.perspective.html" title="fn zng::layout::perspective">perspective</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong> Distance from the Z plane (0) the viewer is, affects 3D transform on the widget’s children.</div></li><li><div class="item-name"><a class="fn" href="fn.perspective_origin.html" title="fn zng::layout::perspective_origin">perspective_origin</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Vanishing point used by 3D transforms in the widget’s children.</div></li><li><div class="item-name"><a class="fn" href="fn.rotate.html" title="fn zng::layout::rotate">rotate</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Rotate transform.</div></li><li><div class="item-name"><a class="fn" href="fn.rotate_x.html" title="fn zng::layout::rotate_x">rotate_x</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Rotate transform.</div></li><li><div class="item-name"><a class="fn" href="fn.rotate_y.html" title="fn zng::layout::rotate_y">rotate_y</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Rotate transform.</div></li><li><div class="item-name"><a class="fn" href="fn.rotate_z.html" title="fn zng::layout::rotate_z">rotate_z</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Same as <a href="fn.rotate.html" title="fn zng::layout::rotate"><code>rotate</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.scale.html" title="fn zng::layout::scale">scale</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Scale transform.</div></li><li><div class="item-name"><a class="fn" href="fn.scale_x.html" title="fn zng::layout::scale_x">scale_x</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Scale X transform.</div></li><li><div class="item-name"><a class="fn" href="fn.scale_xy.html" title="fn zng::layout::scale_xy">scale_xy</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Scale X and Y transform.</div></li><li><div class="item-name"><a class="fn" href="fn.scale_y.html" title="fn zng::layout::scale_y">scale_y</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Scale Y transform.</div></li><li><div class="item-name"><a class="fn" href="fn.size.html" title="fn zng::layout::size">size</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Exact size of the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.skew.html" title="fn zng::layout::skew">skew</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Skew transform.</div></li><li><div class="item-name"><a class="fn" href="fn.skew_x.html" title="fn zng::layout::skew_x">skew_x</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Skew X transform.</div></li><li><div class="item-name"><a class="fn" href="fn.skew_y.html" title="fn zng::layout::skew_y">skew_y</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Skew Y transform.</div></li><li><div class="item-name"><a class="fn" href="fn.slerp_enabled.html" title="fn zng::layout::slerp_enabled">slerp_enabled</a></div><div class="desc docblock-short">Calls <code>f</code> with <a href="../../zng_var/impls/fn.is_slerp_enabled.html" title="fn zng_var::impls::is_slerp_enabled"><code>is_slerp_enabled</code></a> set to <code>enabled</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.slerp_sampler.html" title="fn zng::layout::slerp_sampler">slerp_sampler</a></div><div class="desc docblock-short">Spherical linear interpolation sampler.</div></li><li><div class="item-name"><a class="fn" href="fn.sticky_height.html" title="fn zng::layout::sticky_height">sticky_height</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Retain the widget’s previous height if the new layout height is smaller.
The widget is layout using its previous height as the minimum height constrain.</div></li><li><div class="item-name"><a class="fn" href="fn.sticky_size.html" title="fn zng::layout::sticky_size">sticky_size</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Retain the widget’s previous size if the new layout size is smaller.
The widget is layout using its previous size as the minimum size constrain.</div></li><li><div class="item-name"><a class="fn" href="fn.sticky_width.html" title="fn zng::layout::sticky_width">sticky_width</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Retain the widget’s previous width if the new layout width is smaller.
The widget is layout using its previous width as the minimum width constrain.</div></li><li><div class="item-name"><a class="fn" href="fn.transform.html" title="fn zng::layout::transform">transform</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Custom transform.</div></li><li><div class="item-name"><a class="fn" href="fn.transform_origin.html" title="fn zng::layout::transform_origin">transform_origin</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Point relative to the widget inner bounds around which the <a href="fn.transform.html" title="fn zng::layout::transform"><code>transform</code></a> is applied.</div></li><li><div class="item-name"><a class="fn" href="fn.transform_style.html" title="fn zng::layout::transform_style">transform_style</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Defines how the widget and children are positioned in 3D space.</div></li><li><div class="item-name"><a class="fn" href="fn.translate.html" title="fn zng::layout::translate">translate</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Translate transform.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_x.html" title="fn zng::layout::translate_x">translate_x</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Translate X transform.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_y.html" title="fn zng::layout::translate_y">translate_y</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Translate Y transform.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_z.html" title="fn zng::layout::translate_z">translate_z</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Translate Z transform.</div></li><li><div class="item-name"><a class="fn" href="fn.width.html" title="fn zng::layout::width">width</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Exact width of the widget.</div></li><li><div class="item-name"><a class="fn" href="fn.x.html" title="fn zng::layout::x">x</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Offset on the <em><strong>x</strong></em> axis.</div></li><li><div class="item-name"><a class="fn" href="fn.y.html" title="fn zng::layout::y">y</a></div><div class="desc docblock-short"><strong title='Property function' data-tag='P'><code>P</code></strong>  Offset on the <em><strong>y</strong></em> axis.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.DipBox.html" title="type zng::layout::DipBox">DipBox</a></div><div class="desc docblock-short">A rectangle box in device independent pixels.</div></li><li><div class="item-name"><a class="type" href="type.DipCornerRadius.html" title="type zng::layout::DipCornerRadius">DipCornerRadius</a></div><div class="desc docblock-short">Corner-radius in device independent pixels.</div></li><li><div class="item-name"><a class="type" href="type.DipPoint.html" title="type zng::layout::DipPoint">DipPoint</a></div><div class="desc docblock-short">A point in device independent pixels.</div></li><li><div class="item-name"><a class="type" href="type.DipRect.html" title="type zng::layout::DipRect">DipRect</a></div><div class="desc docblock-short">A rectangle in device independent pixels.</div></li><li><div class="item-name"><a class="type" href="type.DipSideOffsets.html" title="type zng::layout::DipSideOffsets">DipSideOffsets</a></div><div class="desc docblock-short">Side-offsets in device independent pixels.</div></li><li><div class="item-name"><a class="type" href="type.DipSize.html" title="type zng::layout::DipSize">DipSize</a></div><div class="desc docblock-short">A size in device pixels.</div></li><li><div class="item-name"><a class="type" href="type.DipVector.html" title="type zng::layout::DipVector">DipVector</a></div><div class="desc docblock-short">A vector in device independent pixels.</div></li><li><div class="item-name"><a class="type" href="type.PxBox.html" title="type zng::layout::PxBox">PxBox</a></div><div class="desc docblock-short">A rectangle box in device pixels.</div></li><li><div class="item-name"><a class="type" href="type.PxCornerRadius.html" title="type zng::layout::PxCornerRadius">PxCornerRadius</a></div><div class="desc docblock-short">Corner-radius in device pixels.</div></li><li><div class="item-name"><a class="type" href="type.PxPoint.html" title="type zng::layout::PxPoint">PxPoint</a></div><div class="desc docblock-short">A point in device pixels.</div></li><li><div class="item-name"><a class="type" href="type.PxRect.html" title="type zng::layout::PxRect">PxRect</a></div><div class="desc docblock-short">A rectangle in device pixels.</div></li><li><div class="item-name"><a class="type" href="type.PxSideOffsets.html" title="type zng::layout::PxSideOffsets">PxSideOffsets</a></div><div class="desc docblock-short">Side-offsets in device pixels.</div></li><li><div class="item-name"><a class="type" href="type.PxSize.html" title="type zng::layout::PxSize">PxSize</a></div><div class="desc docblock-short">A size in device pixels.</div></li><li><div class="item-name"><a class="type" href="type.PxVector.html" title="type zng::layout::PxVector">PxVector</a></div><div class="desc docblock-short">A vector in device pixels.</div></li></ul></section></div></main></body></html>